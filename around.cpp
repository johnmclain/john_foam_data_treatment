/*
 * Code for Procedure Definition around
 * Generated by ACM V7.3
 */
 #define _WINSOCKAPI_  
#include <windows.h>
#include <winSock2.h>

#include "C:\Users\mike\Desktop\0\acmtest\thefirstround\around.h"
#include "atdll.h"

#include "libssh\libssh.h"
#include "libssh\sftp.h"
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>

/* include any additional header files here */

/* Values for ICALL */
#define ICALL_OUTPUTS 0
#define ICALL_PRECALL 1
#define ICALL_POSTCALL 2
#define ICALL_DERIVS 3
#define ICALL_BOTH 4

/* Values for pIFail return code */
#define IFAIL_OK 1
#define IFAIL_WARN 2
#define IFAIL_SEVERE 3
#define IFAIL_FATAL 4
// Max Line Size
#define MAX_LINE_SIZE 256
int scp_receive(ssh_session session, ssh_scp scp);
int scp_read(ssh_session session);
extern const char filepath[] = "C:/Users/mike/Desktop/data.csv";
int show_remote_files(ssh_session session);
int read_csv_store_to_acm(double * pRealVariable_Out1, int column, int row)
{
 FILE* fd;
 char* str="";
 char strLine[MAX_LINE_SIZE];
 char* p;
 int i,j;
 double** data;
 char* buffer="";

 fd = fopen(filepath, "r");
 if( fd==NULL)
   {
     ACM_Print(-1, "open file csv failed \n");
     return -1;
   }

 ACM_Print(0, "Before Reading \n");

 data = (double **)malloc(sizeof(double*)*row);
 for (i = 0; i<row; i++)
    {
        data[i] = (double*)malloc(sizeof(double)*(column+2)); // b + 2 is to get the row number and distance in csv file
    }

 ACM_Print(0,"Before gets \n");
 str=fgets(strLine, MAX_LINE_SIZE, fd);
 ACM_Print(0,"Header \n %s \n", str);



 for(i=0;i<row;i++)
 {
  j=0;
  ACM_Print(0,"Reading Line %d \n", &i);

    if(fgets(strLine, MAX_LINE_SIZE, fd)!=NULL)
    {
      str = strtok_s(strLine," ",&p);
      if(str!=NULL)
      {
        data[i][j] = strtod(str,NULL);
        ACM_Print(0,"%12.10f ",&data[i][j]);
        j++;
      }

      while(j<column+2)
      {
        str = strtok_s(NULL," ",&p);//for linux "Safe" strtok is strtok_r, for windows it's strtok_s
        if( str!=NULL)
        {
        data[i][j] = strtod(str,NULL); 
        ACM_Print(0,"%12.10f \n",&data[i][j]);//data[i][j]);
        }
        j++;
      }
    }
 }
    ACM_Print(0,"Printing. \n");
   for (i = 0; i < row; i++){
     for (j = 0; j < column+2; j++){
       ACM_Print (0,"%.10f ", (*(data+i)+j) );
        }
        ACM_Print (0,"\n");
    }


 for(i=0;i<row;i++)
 {
  for(j=2;j<column+2;j++)
  {
    pRealVariable_Out1[i*column+j-2]=data[i][j];
  }
 }
 ACM_Print(0,"End Copying \n");


//   ACM_Print(0,"After Reading and Copying, printing. \n");
  /* for (i = 0; i < a; i++){
     for (j = 0; j < b+2; j++){
       ACM_Print (0,"%.10f ", (*(data+i)+j) );
        }
        ACM_Print (0,"\n");
    }
*/

   ACM_Print(0,"freeing data. \n");
    for (i = 0; i < row; i++)
    {
        free(data[i]);
		ACM_Print(0,"freeing Line %d \n", &i);
    }
    free(data);
 
 fclose(fd);
 fd=NULL;
 return 0;
}
/*
 * This function is EXPORTED from the DLL.
 * Do not change its name or signature.
 */
DLL_C_AS_F(void) AROUND_C(
      int *pICall,
      double *pInputs,int *pInSizes,
      double *pOutputs,int *pOutSizes,
      int *pInOffs,int *pOutOffs,
      int *pPropsId,double *pWork,int *pWSize,
      int *pNonZeros, int *pRows, int *pCols, int *pUnused, double *pDerivs,
      int *pIfail)
{
/* Variables used for array accessing */
  int iDim1,iDim2;

/* Protect arguments from accidental change */
  const int ICall = *pICall;     /* type of call */

/* Input arguments */
  const int IntegerParameter_In1 = *(int*)(&pInputs[pInOffs[0]]);
  const int IntegerParameter_In2 = *(int*)(&pInputs[pInOffs[1]]);

/* Output arguments */
  double *pRealVariable_Out1 = (double *)(&pOutputs[pOutOffs[0]]);
#define RealVariable_Out1Dims 2
  int RealVariable_Out1DimsSizes[RealVariable_Out1Dims] = {pOutSizes[0], pOutSizes[1]};
  
  
    ssh_session my_ssh_session = ssh_new();
  
  int verbosity = SSH_LOG_PROTOCOL;
  int port = 22;
  int rc;
  
  const char password[] ="ly5611899";
  const char username[] ="ubuntu";
  const char filename[] ="/home/ubuntu/OpenFOAM/OpenFOAM-v1606+/tutorials/multiphase/multiphaseEulerFoam/bubbleColumn/postProcessing/surfaces/99/alpha.air_Plane.raw";


  if (my_ssh_session == NULL)
  {  
    ACM_Print(0,"Failed to open a seesion");
  }
  else
  {
	  ssh_options_set(my_ssh_session, SSH_OPTIONS_HOST, "118.89.175.96");
	  ssh_options_set(my_ssh_session, SSH_OPTIONS_LOG_VERBOSITY, &verbosity);
	  ssh_options_set(my_ssh_session, SSH_OPTIONS_PORT, &port);
	  
	  rc = ssh_connect(my_ssh_session);
	  if (rc != SSH_OK)
	  {
		ACM_Print(-1, "Error connecting to Server.");
	  }

	  rc = ssh_userauth_password(my_ssh_session, username, password);
	  if (rc != SSH_AUTH_SUCCESS)
	  {
		ACM_Print(-1, "Error authenticating with password: %s\n",
		ssh_get_error(my_ssh_session));
		ssh_disconnect(my_ssh_session);
		ssh_free(my_ssh_session);
	  }
	  else
	  {
		ACM_Print(0, "Login Successful. \n");
	  }

    
	rc = show_remote_files(my_ssh_session);
	rc = scp_read(my_ssh_session);
    if (rc != SSH_OK)
    {
      ACM_Print(-1, "Error in reading file.\n");
    }

   }
   
   ssh_free(my_ssh_session);

/* Now the actual code of the procedure */
ACM_Print(0,"Dim1 size is %d, Dim2 size is %d", &(RealVariable_Out1DimsSizes[0]), &(RealVariable_Out1DimsSizes[1]));
  switch (ICall)
  {
   case ICALL_OUTPUTS:
   case ICALL_BOTH:
      {
      /* TODO: Put your code to compute outputs here */
      /* *pRealVariable_Out1 is an array with 2 dimensions */
      read_csv_store_to_acm(pRealVariable_Out1,RealVariable_Out1DimsSizes[1],RealVariable_Out1DimsSizes[0]);
	  /*for (iDim1=0;iDim1<RealVariable_Out1DimsSizes[0];iDim1++)
	  {
		
		for (iDim2=0;iDim2<RealVariable_Out1DimsSizes[1];iDim2++)
		{
			ACM_Print(0,"Dim1 %d, Dim2 %d", &iDim1, &iDim2);
			pRealVariable_Out1[iDim1*RealVariable_Out1DimsSizes[1]+iDim2]=0;
			ACM_Print(0,"the value is %f", &(pRealVariable_Out1[iDim1*RealVariable_Out1DimsSizes[1]+iDim2]));
		}
	  }*/
      *pIfail = IFAIL_OK; /* TODO: change to IFAIL_OK */
      } /* end dealing with outputs */
      break;

   default:
      {
      ACM_Print(-1,"AROUND was called with ICall=%d, which was not handled",
          &ICall);
      *pIfail = IFAIL_FATAL;
      }
      break;
  } /* end switch ICall */

} /* end AROUND_C */



int show_remote_files(ssh_session session)
{
  ssh_channel channel;
  int rc;
  char buffer[256];
  int nbytes;
  /*
  channel = ssh_channel_new(session);
  if (channel == NULL) return SSH_ERROR;
  rc = ssh_channel_open_session(channel);
  if (rc != SSH_OK)
  {
    ssh_channel_free(channel);
    return rc;
  }
  rc = ssh_channel_request_exec(channel, "ls");
  nbytes = ssh_channel_read(channel, buffer, sizeof(buffer), 0);
  ACM_Print(0,buffer);
  */
 
  channel = ssh_channel_new(session);
  if (channel == NULL) return SSH_ERROR;
  rc = ssh_channel_open_session(channel);
  if (rc != SSH_OK)
  {
    ssh_channel_free(channel);
    return rc;
  }
  rc = ssh_channel_request_exec(channel, "./x.sh");
  if (rc != SSH_OK)
  {
  ssh_channel_close(channel);
  ssh_channel_free(channel);
  return rc;
  }
  nbytes = ssh_channel_read(channel, buffer, sizeof(buffer), 0);
  ACM_Print(0,buffer);
  if (rc != SSH_OK)
  {
  ssh_channel_close(channel);
  ssh_channel_free(channel);
  return rc;
  }

  ssh_channel_close(channel);
  ssh_channel_free(channel);
  return SSH_OK;
}



int scp_receive(ssh_session session, ssh_scp scp)
{
  int rc;
  int size, mode;
  char *filename;
  char *buffer;
  FILE* fd;

  rc = ssh_scp_pull_request(scp);
  if (rc != SSH_SCP_REQUEST_NEWFILE)
  {
    ACM_Print(-1, "Error receiving information about file: %s\n",
            ssh_get_error(session));
    return SSH_ERROR;
  }

  size = ssh_scp_request_get_size(scp);
  filename = _strdup(ssh_scp_request_get_filename(scp));
  mode = ssh_scp_request_get_permissions(scp);
  ACM_Print(0, "Receiving file %s",filename);
  //ACM_Print(0,"Receiving file %s, size %d, permisssions 0%o\n",
          //filename, size, mode);
  free(filename);
  buffer = (char *)malloc(size);
  if (buffer == NULL)
  {
    ACM_Print(-1, "Memory allocation error\n");
    return SSH_ERROR;
  }
  ssh_scp_accept_request(scp);
  rc = ssh_scp_read(scp, buffer, size);
  if (rc == SSH_ERROR)
  {
    ACM_Print(-1, "Error receiving file data: %s\n",
            ssh_get_error(session));
    free(buffer);
    return rc;
  }
  ACM_Print(0,"Done\n");
  //write(1, buffer, size);

  fd = fopen(filepath, "w+");
  fprintf(fd,"%s",buffer);
  free(buffer);
  fclose(fd);

  rc = ssh_scp_pull_request(scp);
  if (rc != SSH_SCP_REQUEST_EOF)
  {
    ACM_Print(-1, "Unexpected request: %s\n",
            ssh_get_error(session));
    return SSH_ERROR;
  }
  return SSH_OK;
}

int scp_read(ssh_session session)
{
  ssh_scp scp;
  int rc;

  scp = ssh_scp_new (session, SSH_SCP_READ, "~/data.csv");
  if (scp == NULL)
  {
    ACM_Print(-1, "Error allocating scp session: %s\n",
            ssh_get_error(session));
    return SSH_ERROR;
  }

  rc = ssh_scp_init(scp);
  if (rc != SSH_OK)
  {
    ACM_Print(-1, "Error initializing scp session: %s\n",
            ssh_get_error(session));
    ssh_scp_free(scp);
    return SSH_ERROR;
  }

  rc = scp_receive(session, scp);
  if (rc != SSH_OK)
  {
    ACM_Print(-1, "Error receiving scp session: %s\n",
            ssh_get_error(session));
    ssh_scp_free(scp);
    return SSH_ERROR;
  }

  ssh_scp_close(scp);
  ssh_scp_free(scp);
  ACM_Print(0,"EndofSCP");
  return SSH_OK;
}


int read_csv_store_to_acm(double * pRealVariable_Out1)
{
 FILE* fd;
 char* str="";
 char strLine[MAX_LINE_SIZE];
 char* p;
 int i,j;
 double** data;
 char* buffer="";

 fd = fopen(filepath, "r");
 if( fd==NULL)
   {
     ACM_Print(-1, "open file csv failed \n");
     return -1;
   }

 ACM_Print(0, "Before Reading \n");

 data = (double **)malloc(sizeof(double*)*10);
 for (i = 0; i<10; i++)
    {
        data[i] = (double*)malloc(sizeof(double)*2);
    }

 ACM_Print(0,"Before gets \n");
 str=fgets(strLine, MAX_LINE_SIZE, fd);
 ACM_Print(0,"Header \n %s \n", str);



 for(i=0;i<10;i++)
 {
  j=0;
  ACM_Print(0,"Reading Line %d \n", &i);

    if(fgets(strLine, MAX_LINE_SIZE, fd)!=NULL)
    {
      str = strtok_s(strLine," ",&p);
      if(str!=NULL)
      {
        data[i][j] = strtod(str,NULL);
        ACM_Print(0,"%12.10f ",&data[i][j]);
        j++;
      }

      while(j<2)
      {
        str = strtok_s(NULL," ",&p);//for linux "Safe" strtok is strtok_r, for windows it's strtok_s
        if( str!=NULL)
        {
        data[i][j] = strtod(str,NULL); 
        ACM_Print(0,"%12.10f \n",&data[i][j]);//data[i][j]);
        }
        j++;
      }
    }
 }

 for(i=0;i<10;i++)
 {
  for(j=0;j<2;j++)
  {
    pRealVariable_Out1[i*2+j]=data[i][j];
  }
 }
 ACM_Print(0,"End Copying \n");
  

   ACM_Print(0,"After Reading and Copying, printing. \n");
   for (i = 0; i < 10; i++){
     for (j = 0; j < 2; j++){
       ACM_Print (0,"%.10f ", (*(data+i)+j) );
        }
        ACM_Print (0,"\n");
    }

   ACM_Print(0,"freeing data. \n");
    for (i = 0; i < 10; i++)
    {
        free(data[i]);
    }
    free(data);
 
 fclose(fd);
 fd=NULL;
 return 0;
}
